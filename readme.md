# Prerequisites and setup

Please pull this repository onto your local machine and perform the setup process.

- Mandatory:
  - Node version 16+ or above
  - NPM version 8.5.0 or above
- Optional:
  - docker
  - docker-compose
  
In the repository you just cloned, you'll find two node.js applications: an event generator application and an event consumer application. Both of these need installation for the required packages, so please navigate inside `client` and `event-generator` folders and perform an `npm install` in each.

We've provided a `docker-compose.yml` file and `Dockerfiles` for each of the projects if you prefer to run the test in a containerized environment. If this is your wish, perform the usual `docker-compose build` and `docker-compose up` in the root folder of the repo.

> Important:
> 
> The ports needed by each of the apps are **3000** and **3001** and these can be changed in the `index.ts`'s of the applications.
> 
> If you run this setup containerized, then you'll only need to map the **client application's outbound port** (which is currently set up as **4041**).
>
> We'll run your solution containerized, so there's no issues with changing these preset values, go ahead and make yourself comfortable working with what we've prepared!

To start the local setup you need to run:
> inside the _client_ folder: **npm run client:start**
> 
> inside the _event-generator_ folder: **npm run server:start**

### All the code you need to submit should be put in the `client` project. The `event-generator` project is only for support (generates the stream of events).

You need to have both processes up & running and after that you can access the http endpoints exposed by the client app. If you don't change anything one such endpoint is `http://localhost:3001/statistics` which routes to the `StatisticsController`. If you decide to change the port (or the hostname, or whatever else) please consider those updates for the examples given below.

`http://localhost:3001/unicorns` will output an empty array `[]` until a unicorn is generated by the event-generator. Keep in mind that this app doesn't need a database, so you won't have persistence between the restarts of the app.

Now let's dive into the story and the actual challenge roadmap for this test!

# Background Story
You've sent a probe on the magical _Kindlands_ distant planet to collect information about the Golden Fields of Wild Unicorns. As this probe is far away and the signal might be delayed for long periods of time, you decide to build an asynchronous data collection mechanism.

The probe will emit a signal whenever an event is observed in the region. The three possible events are:
 - _UNICORN_SIGHTING_ whenever a Unicorn is spotted: `{ name: string, x: number, y: number }`
 - _RAINBOW_APPEARED_ whenever a new Rainbow appears (with an unique id for the rainbow and the time of appearance): `{ id: string, time: Date }`
 - _RAINBOW_DISAPPEARED_ whenever a new Rainbow disappears (with the id of the rainbow that disappeared and the time of the disappearance): `{ id: string, time: Date }`

These signals are intercepted by a client observer application here on Earth, and you'll use this client application to build statistics about Kindlands and the Unicorns.

This client application should be available for any university looking to research the behavior of the Unicorns, so you decide to expose all this data in a RESTful manner.

Right now you're done with linking the Earth client to the probe and you have a constant stream of events.

You've also managed to implement a couple of API endpoints (in the two available controllers `RainbowController` and `UnicornController`) to provide a proof of concept for the Town University:
- get all sighted unicorns (`http://localhost:[client-app-port]/unicorns`)
- get all rainbows (`http://localhost:[client-app-port]/rainbows`)
- get random Unicorn info (`http://localhost:[client-app-port]/unicorns/random`)
- get Unicorn info by querying (`http://localhost:[client-app-port]/unicorns/get_one_by_key?key=[number]`)

You have two services:
- `RainbowService` for handling the rainbow logic (both from the controller and the probe client)
- `UnicornService` for handling the unicorn logic (both from the controller and the probe client)

The following chapter lists all the issues that need urgent fixing.

# Roadmap
1. You've noticed that the REST API url's are not properly thought. Especially that `get_one_by_key` endpoint. Please refactor the routes to follow RESTful APIs best practices. (estimated time: 10 minutes)
2. Please implement the logic that handles the disappearance of the rainbows. There's a stub in the rainbow service that needs to be filled with the proper logic. (estimated time: 5 minutes)
3. Please implement the `/statistics` endpoint that can be found in the `StatisticsController`. This endpoint should return the following information: (estimated time: 30 minutes)
   1. how many unicorns were sighted
   2. how many rainbows were sighted
   3. the rainbow with the longest duration and its duration
   4. the rainbow with the shortest duration and its duration
4. You've already implemented a stub for defining a dangerous area (where Unicorns should not be seen). Please save the area coordinates (top-left, bottom-right) in the UnicornService and use this information to keep a log (simple array of objects with whatever information you feel appropriate) of all the Unicorns that are spotted in the area. (estimated time: 30 minutes)
5. Update the statistics endpoint to reflect how many unicorns were spotted in the danger zone, and provide a list of their names. (15 minutes)

# Important submission information

**Please commit once per roadmap issue.** If you work with partial commits on local, that's fine, but make sure you squash before pushing upstream.

You can change the linting and/or formatting rules if you feel more comfortable adhering to some other standards. **But please make sure you do this in a single commit, before any other work is submitted.**

We will **not** keep track of your commit times, and there's **no "mandatory solve this in one sitting" rule**. The times displayed on each roadmap issue are for you to evaluate the complexity of each item.

Whenever you're done, ping the person who handed you the link to this repo.

HAVE FUN!
